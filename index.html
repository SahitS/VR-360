<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>360 Photo Sequence Viewer - Benin (Three.js + WebXR)</title>
  <!-- Load Three.js and its OrbitControls properly -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Additional Three.js components needed for VR -->
  <script>
    // Load required Three.js modules after THREE is defined
    document.addEventListener('DOMContentLoaded', () => {
      // Load OrbitControls
      const orbitScript = document.createElement('script');
      orbitScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
      document.head.appendChild(orbitScript);
      
      // Load VR related modules
      const vrButtonScript = document.createElement('script');
      vrButtonScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js';
      document.head.appendChild(vrButtonScript);

      // Load XR Controller Model Factory
      const xrControllerScript = document.createElement('script');
      xrControllerScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/XRControllerModelFactory.js';
      document.head.appendChild(xrControllerScript);
      
      // Initialize once everything is loaded
      let componentsLoaded = 0;
      const totalComponents = 3;
      
      function checkInitialize() {
        componentsLoaded++;
        if (componentsLoaded >= totalComponents) {
          initializeApplication();
        }
      }
      
      orbitScript.onload = checkInitialize;
      vrButtonScript.onload = checkInitialize;
      xrControllerScript.onload = checkInitialize;
      
      orbitScript.onerror = (e) => {
        console.error("Failed to load OrbitControls", e);
        createFallbackOrbitControls();
        checkInitialize();
      };
      
      vrButtonScript.onerror = (e) => {
        console.error("Failed to load VR components", e);
        createFallbackVRComponents();
        checkInitialize();
      };

      xrControllerScript.onerror = (e) => {
        console.error("Failed to load XR Controller Model Factory", e);
        createFallbackXRControllers();
        checkInitialize();
      };
    });
  </script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background-color: #000;
    }
    
    #container {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      color: white;
      font-family: Arial, sans-serif;
    }
    
    .loading-text {
      font-size: 24px;
      margin-top: 20px;
    }
    
    .progress-bar {
      width: 300px;
      height: 20px;
      background-color: #333;
      border-radius: 10px;
      margin-top: 20px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background-color: #4285f4;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .location-name {
      margin-top: 10px;
      font-size: 18px;
    }
    
    /* Debug panel */
    #debugContainer {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 400px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      font-family: monospace;
      z-index: 1000;
      border-radius: 5px;
      padding: 10px;
      max-height: 300px;
      display: none;
    }
    
    #debugHeader {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      border-bottom: 1px solid #444;
      padding-bottom: 5px;
    }
    
    #debugPanelToggle {
      cursor: pointer;
      user-select: none;
    }
    
    #debugPanel {
      height: 200px;
      overflow-y: auto;
      font-size: 12px;
      line-height: 1.5;
    }
    
    .debug-entry {
      margin-bottom: 3px;
      border-bottom: 1px dotted #333;
      word-wrap: break-word;
    }
    
    .debug-info {
      color: #8ff;
    }
    
    .debug-error {
      color: #f88;
    }
    
    /* Instructions */
    .instructions {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      text-align: center;
      z-index: 100;
      transition: opacity 0.5s ease;
    }
    
    .instructions p {
      margin: 5px 0;
    }
    
    .key {
      background-color: #444;
      padding: 2px 8px;
      border-radius: 3px;
      margin: 0 3px;
    }
    
    /* Navigation controls */
    .nav-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      justify-content: center;
      z-index: 100;
    }
    
    .nav-button {
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 5px;
      padding: 12px 24px;
      margin: 0 10px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.2s ease;
    }
    
    .nav-button:hover {
      background-color: rgba(66, 133, 244, 0.8);
    }
    
    /* Info panel */
    .info-panel {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 5px;
      padding: 10px;
      font-size: 14px;
      z-index: 100;
      max-width: 250px;
    }
    
    .info-panel .location {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .info-panel .position {
      font-size: 12px;
      color: #aaa;
    }
    
    /* Error notification */
    .error-notification {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 50, 50, 0.9);
      color: white;
      padding: 15px 25px;
      border-radius: 5px;
      z-index: 9998;
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    /* Thumbnail preview */
    .thumbnail-preview {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 5px;
      padding: 5px;
      z-index: 100;
      display: flex;
      justify-content: center;
      gap: 5px;
    }
    
    .thumbnail {
      width: 50px;
      height: 30px;
      opacity: 0.6;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s ease;
    }
    
    .thumbnail:hover {
      opacity: 0.8;
    }
    
    .thumbnail.active {
      opacity: 1;
      border-color: #4285f4;
    }
    
    /* VR specific styles */
    #vrButton {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 200;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  
  <!-- Loading overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <h2>Loading 360 Photo Sequence</h2>
    <div class="loading-text" id="loadingText">Initializing viewer</div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="location-name" id="locationName">Benin, West Africa</div>
  </div>
  
  <!-- Error notification -->
  <div class="error-notification" id="errorNotification"></div>
  
  <!-- Debug panel -->
  <div id="debugContainer">
    <div id="debugHeader">
      <span>Debug Information</span>
      <span id="debugPanelToggle">×</span>
    </div>
    <div id="debugPanel"></div>
  </div>
  
  <!-- Instructions -->
  <div class="instructions" id="instructions">
    <p>Use <span class="key">←</span> and <span class="key">→</span> arrows or buttons to navigate</p>
    <p>Drag to look around • Use mouse wheel to zoom</p>
    <p>Press <span class="key">VR</span> button to enter VR mode</p>
    <p>In VR: Point controller at ground arrows to navigate</p>
  </div>
  
  <!-- Info panel -->
  <div class="info-panel" id="infoPanel">
    <div class="location">Benin Street View</div>
    <div class="position" id="positionInfo">Loading...</div>
    <div id="photoCounter">Image 1 of 7</div>
  </div>
  
  <!-- Navigation controls -->
  <div class="nav-controls">
    <button class="nav-button" id="prevButton">Previous</button>
    <button class="nav-button" id="nextButton">Next</button>
  </div>
  
  <!-- Thumbnail preview -->
  <div class="thumbnail-preview" id="thumbnailPreview"></div>

  <script>
    // ===== CONFIG =====
    // Always use placeholder images since we can't access local files
    const USE_PLACEHOLDERS = false;
    
    // Placeholder images (Royalty-free panoramas)
    const PLACEHOLDER_IMAGES = [
      'assets/Dummy1.jpg',
      'assets/Dummy2.jpg',
    ];
    
    // Original image paths (we won't be able to use these in this demo)
    const PANORAMA_IMAGES = [
      'assets/2025-01.jpg',
      'assets/2025-01 (1).jpg', 
      'assets/2025-01 (2).jpg',
      'assets/2025-01 (3).jpg',
      'assets/2025-01 (4).jpg',
      'assets/2025-01 (5).jpg',
      'assets/2025-01 (6).jpg',
      'assets/2025-01 (7).jpg',
      'assets/2025-01 (8).jpg',
      'assets/2025-01 (9).jpg',
      'assets/2025-01 (10).jpg',
      'assets/2025-01 (11).jpg',
      'assets/2025-01 (12).jpg',
      'assets/2025-01 (13).jpg',
      'assets/2025-01 (14).jpg',
      'assets/2025-01 (15).jpg',
      'assets/2025-01 (16).jpg',
      'assets/2025-01 (17).jpg',
      'assets/2025-01 (18).jpg',
      'assets/2025-01 (19).jpg',
    ];
    
    // Location data for each panorama
    const PANORAMA_LOCATIONS = [
      { latitude: 6.613033413497521, longitude: 2.26106129026251 },
      { latitude: 6.613103637722834, longitude: 2.260996330854332 },
      { latitude: 6.613156826485127, longitude: 2.2609223349537757 },
      { latitude: 6.613189824531064, longitude: 2.2608311051065715 },
      { latitude: 6.613192329611306, longitude: 2.2607369030113826 },
      { latitude: 6.6131575474949456, longitude: 2.2606474016144062 },
      { latitude: 6.613102334844579, longitude: 2.2605714245433943 },
      { latitude: 6.603178333210233, longitude: 2.2532221547928235 },
      { latitude: 6.603088389390056, longitude: 2.25325145063276 },
      { latitude: 6.603015678470221, longitude: 2.253309800936702 },
      { latitude: 6.602963139039731, longitude: 2.2533877601346544 },
      { latitude: 6.602930263717786, longitude: 2.2534726303435746 },
      { latitude: 6.60292926849661, longitude: 2.2535073080794956 },
      { latitude: 6.602917779224612, longitude: 2.2536009736538163 },
      { latitude: 6.602903598882117, longitude: 2.253693276658227 },
      { latitude: 6.602882440696533, longitude: 2.253786982020869 },
      { latitude: 6.60285119997703, longitude: 2.253878564852968 },
      { latitude: 6.602804918397261, longitude: 2.2539618537904373 },
      { latitude: 6.60274820990419, longitude: 2.254040058652618 },
      { latitude: 6.602691621523119, longitude: 2.2541138229844084 }
    ];

    // Navigation points configuration - specific coordinates for each panorama
    const NAVIGATION_POINTS = [
      // Frame 0 - first panorama
      {
        frames: {
          forward: { index: 1, position: { x: 0, y: 0.01, z: -5 } },
          backward: null // No backward for first panorama
        }
      },
      // Frame 1
      {
        frames: {
          forward: { index: 2, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 0, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 2
      {
        frames: {
          forward: { index: 3, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 1, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 3
      {
        frames: {
          forward: { index: 4, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 2, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 4
      {
        frames: {
          forward: { index: 5, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 3, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 5
      {
        frames: {
          forward: { index: 6, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 4, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 6
      {
        frames: {
          forward: { index: 7, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 5, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 7
      {
        frames: {
          forward: { index: 8, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 6, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 8
      {
        frames: {
          forward: { index: 9, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 7, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 9
      {
        frames: {
          forward: { index: 10, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 8, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 10
      {
        frames: {
          forward: { index: 11, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 9, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 11
      {
        frames: {
          forward: { index: 12, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 10, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 12
      {
        frames: {
          forward: { index: 13, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 11, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 13
      {
        frames: {
          forward: { index: 14, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 12, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 14
      {
        frames: {
          forward: { index: 15, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 13, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 15
      {
        frames: {
          forward: { index: 16, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 14, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 16
      {
        frames: {
          forward: { index: 17, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 15, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 17
      {
        frames: {
          forward: { index: 18, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 16, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 18
      {
        frames: {
          forward: { index: 19, position: { x: 0, y: 0.01, z: -5 } },
          backward: { index: 17, position: { x: 0, y: 0.01, z: 5 } }
        }
      },
      // Frame 19 - last panorama
      {
        frames: {
          forward: null, // No forward for last panorama
          backward: { index: 18, position: { x: 0, y: 0.01, z: 5 } }
        }
      }
    ];
    
    // Debug mode
    const DEBUG = true;

    // ===== GLOBAL VARIABLES =====
    let currentPhotoIndex = 0;
    let isLoading = true;
    
    // Three.js variables
    let camera, scene, renderer;
    let controls;
    let sphere;
    let loadingManager;
    let textureLoader;
    
    // VR specific variables
    let controller1, controller2;
    let raycaster, intersected;
    let forwardNavigator, backwardNavigator;
    let isVRMode = false;
    // VR navigation cooldown to prevent multiple selections
    let navigationCooldown = false;
    let cooldownTime = 1000; // 1 second cooldown between navigation actions
    
    // ===== DEBUG FUNCTIONS =====
    function log(message, obj) {
      if (DEBUG) {
        if (obj) {
          console.log(`[DEBUG] ${message}`, obj);
          appendToDebugPanel(`${message}: ${JSON.stringify(obj)}`);
        } else {
          console.log(`[DEBUG] ${message}`);
          appendToDebugPanel(message);
        }
      }
    }

    function error(message, err) {
      console.error(`[ERROR] ${message}`, err);
      appendToDebugPanel(`ERROR: ${message} - ${err?.message || err}`, 'error');
      
      // Show error notification
      showErrorNotification(`${message}. ${err?.message || ''}`);
    }

    function showErrorNotification(message, duration = 4000) {
      const notification = document.getElementById('errorNotification');
      notification.textContent = message;
      notification.style.opacity = '1';
      
      setTimeout(() => {
        notification.style.opacity = '0';
      }, duration);
    }

    function appendToDebugPanel(message, type = 'info') {
      const debugPanel = document.getElementById('debugPanel');
      if (debugPanel) {
        const entry = document.createElement('div');
        entry.className = `debug-entry debug-${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        debugPanel.appendChild(entry);
        
        // Auto-scroll to bottom
        debugPanel.scrollTop = debugPanel.scrollHeight;
        
        // Limit number of entries
        if (debugPanel.children.length > 100) {
          debugPanel.removeChild(debugPanel.children[0]);
        }
      }
    }
    
    // Force close loading screen after timeout
    function forceCloseLoadingScreen() {
      const MAX_LOADING_TIME = 10000; // 10 seconds
      
      setTimeout(() => {
        if (isLoading) {
          log('Force closing loading screen after timeout');
          document.getElementById('loadingOverlay').style.display = 'none';
          isLoading = false;
        }
      }, MAX_LOADING_TIME);
    }

    // Create fallback implementations if modules fail to load
    function createFallbackOrbitControls() {
      log('Creating fallback OrbitControls');
      
      // Create a simple implementation that mimics the basic functionality
      THREE.OrbitControls = function(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        
        this.enableZoom = true;
        this.enablePan = true;
        this.rotateSpeed = 1.0;
        this.zoomSpeed = 1.0;
        this.enableDamping = false;
        this.dampingFactor = 0.25;
        
        let isUserInteracting = false;
        let onPointerDownPointerX = 0;
        let onPointerDownPointerY = 0;
        let phi = 0, theta = 0;
        let onPointerDownPhi = 0;
        let onPointerDownTheta = 0;
        
        const scope = this;
        
        function onMouseDown(event) {
          if (event.button === 0) { // left mouse button
            isUserInteracting = true;
            onPointerDownPointerX = event.clientX;
            onPointerDownPointerY = event.clientY;
            onPointerDownTheta = theta;
            onPointerDownPhi = phi;
          }
        }
        
        function onMouseMove(event) {
          if (isUserInteracting) {
            theta = onPointerDownTheta - ((event.clientX - onPointerDownPointerX) * 0.01 * scope.rotateSpeed);
            phi = onPointerDownPhi + ((event.clientY - onPointerDownPointerY) * 0.01 * scope.rotateSpeed);
            
            // Limit phi to avoid flipping
            phi = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, phi));
            
            camera.target = new THREE.Vector3();
            camera.lookAt(camera.target);
            camera.rotation.y = theta;
            camera.rotation.x = phi;
          }
        }
        
        function onMouseUp() {
          isUserInteracting = false;
        }
        
        function onMouseWheel(event) {
          if (scope.enableZoom) {
            const delta = event.deltaY || event.detail || -event.wheelDelta;
            if (delta > 0) {
              scope.camera.fov = Math.min(scope.camera.fov + 1, 100);
            } else {
              scope.camera.fov = Math.max(scope.camera.fov - 1, 30);
            }
            scope.camera.updateProjectionMatrix();
          }
        }
        
        domElement.addEventListener('mousedown', onMouseDown, false);
        domElement.addEventListener('mousemove', onMouseMove, false);
        domElement.addEventListener('mouseup', onMouseUp, false);
        domElement.addEventListener('wheel', onMouseWheel, false);
        domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox
        
        this.update = function() {
          // Does nothing in simple version unless damping is enabled
        };
        
        this.dispose = function() {
          domElement.removeEventListener('mousedown', onMouseDown, false);
          domElement.removeEventListener('mousemove', onMouseMove, false);
          domElement.removeEventListener('mouseup', onMouseUp, false);
          domElement.removeEventListener('wheel', onMouseWheel, false);
          domElement.removeEventListener('DOMMouseScroll', onMouseWheel, false);
        };
      };
      
      log('Fallback OrbitControls created');
    }

    // Create fallback for VR components
    function createFallbackVRComponents() {
      log('Creating fallback VR components');
      
      // Create a simple VRButton that just displays a message
      THREE.VRButton = {
        createButton: function(renderer) {
          const button = document.createElement('button');
          button.style.display = 'block';
          button.style.padding = '12px 24px';
          button.style.border = 'none';
          button.style.borderRadius = '5px';
          button.style.background = '#0066ff';
          button.style.color = '#fff';
          button.style.font = 'normal 16px sans-serif';
          button.textContent = 'VR NOT SUPPORTED';
          
          button.onclick = function() {
            showErrorNotification('WebXR VR not supported in this browser', 3000);
          };
          
          return button;
        }
      };
      
      log('Fallback VR components created');
    }

    // Main initialization function
    function initializeApplication() {
      log('Initializing application');
      
      // Initialize debug panel
      initializeDebugPanel();
      
      // Setup loading animation
      startLoadingAnimation();
      
      // Initialize Three.js
      initThreeJs();
      
      // Set up event handlers
      setupEventListeners();
      
      // Update instructions for ground-based navigation
      updateInstructions();
      
      // Force close loading screen if it gets stuck
      forceCloseLoadingScreen();
      
      // Create thumbnails
      createThumbnails();
    }

    function updateInstructions() {
      const instructions = document.getElementById('instructions');
      if (instructions) {
        instructions.innerHTML = `
          <p>Use <span class="key">←</span> and <span class="key">→</span> arrows or buttons to navigate</p>
          <p>Drag to look around • Use mouse wheel to zoom</p>
          <p>Press <span class="key">VR</span> button to enter VR mode</p>
          <p>In VR: Point controller at ground arrows to navigate</p>
        `;
      }
    }

    function initializeDebugPanel() {
      document.getElementById('debugPanelToggle').addEventListener('click', function() {
        document.getElementById('debugContainer').style.display = 'none';
      });
      
      // Toggle debug panel with 'D' key
      window.addEventListener('keydown', function(evt) {
        if (evt.key === 'd' || evt.key === 'D') {
          const debugPanel = document.getElementById('debugContainer');
          debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
        }
      });
      
      // Show debug panel by default in debug mode
      if (DEBUG) {
        document.getElementById('debugContainer').style.display = 'block';
      }
    }

    // Show loading animation
    function startLoadingAnimation() {
      let progress = 0;
      const interval = setInterval(() => {
        progress += 3;
        document.getElementById('progressFill').style.width = `${progress}%`;
        if (progress >= 95) {
          clearInterval(interval);
        }
      }, 100);
    }

    // Initialize Three.js scene
    function initThreeJs() {
      log('Initializing Three.js');
      
      // Set up the loading manager to track texture loading progress
      loadingManager = new THREE.LoadingManager();
      
      loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
        const progress = Math.floor((itemsLoaded / itemsTotal) * 100);
        log(`Loading: ${progress}% (${itemsLoaded}/${itemsTotal})`);
        document.getElementById('progressFill').style.width = `${progress}%`;
      };
      
      loadingManager.onLoad = function() {
        log('All textures loaded successfully');
        document.getElementById('progressFill').style.width = '100%';
        setTimeout(() => {
          document.getElementById('loadingOverlay').style.display = 'none';
          isLoading = false;
        }, 500);
      };
      
      loadingManager.onError = function(url) {
        error(`Error loading texture: ${url}`);
        // Force-hide loading screen and continue with fallback
        setTimeout(() => {
          document.getElementById('loadingOverlay').style.display = 'none';
          isLoading = false;
        }, 500);
      };
      
      // Create texture loader
      textureLoader = new THREE.TextureLoader(loadingManager);
      
      // Create scene
      scene = new THREE.Scene();
      
      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 0.1); // Small offset to avoid issues
      
      // Create renderer with WebXR support
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.xr.enabled = true; // Enable WebXR
      document.getElementById('container').appendChild(renderer.domElement);
      
      // Add VR button
      try {
        document.body.appendChild(THREE.VRButton.createButton(renderer));
      } catch (err) {
        error("Error creating VR button", err);
        createFallbackVRComponents();
        document.body.appendChild(THREE.VRButton.createButton(renderer));
      }
      
      // Create sphere geometry for the panorama
      const geometry = new THREE.SphereGeometry(500, 60, 40);
      // Flip the geometry inside out
      geometry.scale(-1, 1, 1);
      
      // Create a basic material initially (will be replaced when texture loads)
      const material = new THREE.MeshBasicMaterial({
        color: 0x000000
      });
      
      // Create a mesh with the geometry and material
      sphere = new THREE.Mesh(geometry, material);
      scene.add(sphere);
      
      try {
        // Add controls for panning and zooming
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableZoom = true;
        controls.enablePan = false;
        controls.rotateSpeed = 0.3;
        controls.zoomSpeed = 1.0;
        controls.enableDamping = true;
        controls.dampingFactor = 0.2;
      } catch (e) {
        error("Error creating OrbitControls", e);
        // Try creating the fallback controls again
        createFallbackOrbitControls();
        controls = new THREE.OrbitControls(camera, renderer.domElement);
      }
      
      // Setup VR components
      setupVRComponents();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize, false);
      
      // Start render loop
      renderer.setAnimationLoop(animate);
      
      // Load the first panorama
      loadPanorama(currentPhotoIndex);
    }

    // Setup VR components
    function setupVRComponents() {
      // Create a raycaster for controller interaction
      raycaster = new THREE.Raycaster();
      
      // Create controllers
      controller1 = renderer.xr.getController(0);
      controller1.addEventListener('selectstart', onSelectStart);
      controller1.addEventListener('selectend', onSelectEnd);
      scene.add(controller1);
      
      controller2 = renderer.xr.getController(1);
      controller2.addEventListener('selectstart', onSelectStart);
      controller2.addEventListener('selectend', onSelectEnd);
      scene.add(controller2);
      
      // Create controller models (visible in VR)
      try {
        const controllerModelFactory = new THREE.XRControllerModelFactory();
        
        const controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);
        
        const controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);
      } catch (err) {
        error("Error creating controller models", err);
        // Continue without controller models
      }
      
      // Create path-aware navigation arrows
      createPathAwareNavigationArrows();
      
      // Add line for controller pointing ray
      const geometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, -1)
      ]);
      
      const line = new THREE.Line(geometry);
      line.name = 'ray';
      line.scale.z = 10; // Make ray longer to reach ground
      
      controller1.add(line.clone());
      controller2.add(line.clone());
      
      // Listen for VR session start/end
      renderer.xr.addEventListener('sessionstart', () => {
        log('VR session started');
        isVRMode = true;
        showVRNavigationArrows();
        // Hide non-VR UI elements
        document.querySelectorAll('.nav-controls, .info-panel, .instructions, .thumbnail-preview').forEach(el => {
          el.style.display = 'none';
        });
      });
      
      renderer.xr.addEventListener('sessionend', () => {
        log('VR session ended');
        isVRMode = false;
        hideVRNavigationArrows();
        // Restore non-VR UI elements
        document.querySelectorAll('.nav-controls, .info-panel, .instructions, .thumbnail-preview').forEach(el => {
          el.style.display = '';
        });
      });
    }

    // Create path-aware navigation arrows for VR
    function createPathAwareNavigationArrows() {
      log('Creating path-aware navigation arrows');
      
      // === FORWARD ARROW ===
      forwardNavigator = new THREE.Group();
      forwardNavigator.name = 'forwardNavigator';
      forwardNavigator.userData.isNavigationArrow = true;
      forwardNavigator.userData.direction = 'forward';
      
      // Create arrow shape on ground
      const forwardArrowShape = new THREE.Shape();
      // Draw a chevron matching Google Street View style
      forwardArrowShape.moveTo(0, -0.25);  // top point
      forwardArrowShape.lineTo(0.2, 0.15); // right point
      forwardArrowShape.lineTo(0, 0.05);   // middle indent
      forwardArrowShape.lineTo(-0.2, 0.15); // left point
      forwardArrowShape.lineTo(0, -0.25);  // back to top
      
      const forwardArrowGeometry = new THREE.ShapeGeometry(forwardArrowShape);
      // Rotate to lay flat on ground
      forwardArrowGeometry.rotateX(-Math.PI / 2);
      
      const forwardArrowMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      
      const forwardArrow = new THREE.Mesh(forwardArrowGeometry, forwardArrowMaterial);
      // Elevate slightly above ground to prevent z-fighting
      forwardArrow.position.y = 0.01;
      forwardNavigator.add(forwardArrow);
      
      // === BACKWARD ARROW ===
      backwardNavigator = new THREE.Group();
      backwardNavigator.name = 'backwardNavigator';
      backwardNavigator.userData.isNavigationArrow = true;
      backwardNavigator.userData.direction = 'backward';
      
      // Create arrow shape on ground
      const backwardArrowShape = new THREE.Shape();
      // Draw a chevron pointing backward
      backwardArrowShape.moveTo(0, 0.25);  // bottom point
      backwardArrowShape.lineTo(0.2, -0.15); // right point
      backwardArrowShape.lineTo(0, -0.05);   // middle indent
      backwardArrowShape.lineTo(-0.2, -0.15); // left point
      backwardArrowShape.lineTo(0, 0.25);  // back to bottom
      
      const backwardArrowGeometry = new THREE.ShapeGeometry(backwardArrowShape);
      // Rotate to lay flat on ground
      backwardArrowGeometry.rotateX(-Math.PI / 2);
      
      const backwardArrowMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      
      const backwardArrow = new THREE.Mesh(backwardArrowGeometry, backwardArrowMaterial);
      // Elevate slightly above ground to prevent z-fighting
      backwardArrow.position.y = 0.01;
      backwardNavigator.add(backwardArrow);
      
      // Add to scene but hide initially
      forwardNavigator.visible = false;
      backwardNavigator.visible = false;
      
      scene.add(forwardNavigator);
      scene.add(backwardNavigator);
      
      log('Path-aware navigation arrows created');
    }

    // Position path-aware arrows for the current panorama
    function positionPathAwareArrows() {
      if (!isVRMode || !forwardNavigator || !backwardNavigator) return;
      
      const navPoints = NAVIGATION_POINTS[currentPhotoIndex].frames;
      
      // Get camera position and direction (just for initial orientation - arrows will stay fixed)
      const cameraPosition = new THREE.Vector3();
      camera.getWorldPosition(cameraPosition);
      
      const cameraDirection = new THREE.Vector3(0, 0, -1);
      cameraDirection.applyQuaternion(camera.quaternion);
      
      // Project direction onto xz-plane (ground)
      const groundDirection = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
      
      // Set forward arrow visibility and position
      if (navPoints.forward) {
        forwardNavigator.visible = true;
        
        // Calculate path direction between current and next panorama
        const currentLoc = PANORAMA_LOCATIONS[currentPhotoIndex];
        const nextLoc = PANORAMA_LOCATIONS[navPoints.forward.index];
        
        // Place arrow on the ground at specified position
        const forwardPos = new THREE.Vector3();
        forwardPos.copy(cameraPosition);
        forwardPos.y = navPoints.forward.position.y;
        
        // Position relative to camera, but in the direction of the path
        const pathDirection = calculatePathDirection(currentLoc, nextLoc);
        forwardPos.x += navPoints.forward.position.x;
        forwardPos.z += navPoints.forward.position.z * Math.cos(pathDirection);
        
        // Adjust for path angle
        forwardNavigator.position.copy(forwardPos);
        forwardNavigator.rotation.y = pathDirection;
      } else {
        forwardNavigator.visible = false;
      }
      
      // Set backward arrow visibility and position
      if (navPoints.backward) {
        backwardNavigator.visible = true;
        
        // Calculate path direction between current and previous panorama
        const currentLoc = PANORAMA_LOCATIONS[currentPhotoIndex];
        const prevLoc = PANORAMA_LOCATIONS[navPoints.backward.index];
        
        // Place arrow on the ground at specified position
        const backwardPos = new THREE.Vector3();
        backwardPos.copy(cameraPosition);
        backwardPos.y = navPoints.backward.position.y;
        
        // Position relative to camera, but in the direction of the path
        const pathDirection = calculatePathDirection(currentLoc, prevLoc);
        backwardPos.x += navPoints.backward.position.x;
        backwardPos.z += navPoints.backward.position.z * Math.cos(pathDirection);
        
        // Adjust for path angle
        backwardNavigator.position.copy(backwardPos);
        backwardNavigator.rotation.y = pathDirection;
      } else {
        backwardNavigator.visible = false;
      }
      
      log('Navigation arrows positioned according to path data');
    }
    
    // Calculate direction angle between two panorama locations
    function calculatePathDirection(loc1, loc2) {
      // Calculate angle based on GPS coordinates
      return Math.atan2(
        loc2.longitude - loc1.longitude,
        loc2.latitude - loc1.latitude
      );
    }

    // Show/hide VR navigation arrows
    function showVRNavigationArrows() {
      log('Showing VR navigation arrows');
      
      if (forwardNavigator && backwardNavigator) {
        // Position arrows according to current panorama configuration
        positionPathAwareArrows();
      } else {
        error('Cannot show navigation arrows - they are not initialized');
      }
    }

    function hideVRNavigationArrows() {
      if (forwardNavigator && backwardNavigator) {
        forwardNavigator.visible = false;
        backwardNavigator.visible = false;
      }
    }

    // Handle VR controller select events
    function onSelectStart(event) {
      if (navigationCooldown) return; // Skip if in cooldown period
      
      const controller = event.target;
      
      // Check for intersections with navigation arrows
      handleControllerIntersection(controller);
    }

    function onSelectEnd(event) {
      // Reset intersected object
      intersected = null;
    }

    // Updated controller intersection handler
    function handleControllerIntersection(controller) {
      if (!isVRMode || navigationCooldown) return;
      
      // Create a temp vector to store controller direction
      const tempMatrix = new THREE.Matrix4();
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      
      // Check intersection with navigation arrows
      const intersects = raycaster.intersectObjects([
        ...forwardNavigator.children, 
        ...backwardNavigator.children
      ]);
      
      if (intersects.length > 0) {
        // Find the parent group that has navigation data
        let targetObject = intersects[0].object;
        while (targetObject && !targetObject.parent.userData.isNavigationArrow) {
          targetObject = targetObject.parent;
        }
        
        // If we found a navigation arrow, use it
        if (targetObject && targetObject.parent.userData.isNavigationArrow) {
          intersected = targetObject.parent;
          
          // Set navigation cooldown to prevent continuous navigation
          navigationCooldown = true;
          
          // Visual feedback - pulse the arrow
          const originalScale = targetObject.parent.scale.x;
          targetObject.parent.scale.set(1.5, 1, 1.5);
          targetObject.material.opacity = 1.0;
          
          // Navigate based on direction
          if (targetObject.parent.userData.direction === 'forward') {
            log('Forward arrow selected - navigating next');
            navigateNext();
          } else if (targetObject.parent.userData.direction === 'backward') {
            log('Backward arrow selected - navigating previous');
            navigatePrev();
          }
          
          // Reset cooldown after delay
          setTimeout(() => {
            if (targetObject && targetObject.parent) {
              targetObject.parent.scale.set(originalScale, 1, originalScale);
              if (targetObject.material) {
                targetObject.material.opacity = 0.9;
              }
            }
            navigationCooldown = false;
            log('Navigation cooldown ended');
          }, cooldownTime);
        }
      }
    }

    // Handle window resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Check for controller hover to highlight arrows
    function checkControllerHover(controller) {
      if (!isVRMode) return;
      
      // Create a temp vector to store controller direction
      const tempMatrix = new THREE.Matrix4();
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      
      // Check intersection with all parts of the navigation arrows
      const intersects = raycaster.intersectObjects([
        ...forwardNavigator.children, 
        ...backwardNavigator.children
      ]);
      
      // Reset all arrow opacities and scales
      if (forwardNavigator) {
        forwardNavigator.children.forEach(child => {
          if (child.material) {
            child.material.opacity = 0.9;
          }
        });
        forwardNavigator.scale.set(1, 1, 1);
      }
      
      if (backwardNavigator) {
        backwardNavigator.children.forEach(child => {
          if (child.material) {
            child.material.opacity = 0.9;
          }
        });
        backwardNavigator.scale.set(1, 1, 1);
      }
      
      // Apply hover effect to intersected arrow
      if (intersects.length > 0) {
        // Find the parent group that has navigation data
        let targetObject = intersects[0].object;
        while (targetObject && !targetObject.parent.userData.isNavigationArrow) {
          targetObject = targetObject.parent;
        }
        
        if (targetObject && targetObject.parent.userData.isNavigationArrow) {
          // Hover effect - increase opacity and scale
          if (targetObject.material) {
            targetObject.material.opacity = 1.0;
          }
          
          // Make arrow larger on hover
          targetObject.parent.scale.set(1.2, 1, 1.2);
        }
      }
    }

    // Animation loop
    function animate() {
      if (controls) {
        controls.update(); // Required for damping
      }
      
      // In VR, check for controller intersections for highlighting arrows
      if (isVRMode) {
        if (controller1 && !navigationCooldown) {
          checkControllerHover(controller1);
        }
        if (controller2 && !navigationCooldown) {
          checkControllerHover(controller2);
        }
      }
      
      renderer.render(scene, camera);
    }

    // Load panorama by index
    function loadPanorama(index) {
      // Use the correct image array based on USE_PLACEHOLDERS setting
      const images = USE_PLACEHOLDERS ? PLACEHOLDER_IMAGES : PANORAMA_IMAGES;
      log(`Loading panorama ${index + 1}/${images.length}`);
      
      // Update UI displays
      updateUIForCurrentPhoto(index);
      
      // Select the right image source
      const imageSrc = images[index];
      
      if (!imageSrc) {
        error(`No image source available for index ${index}`);
        return;
      }
      
      // Show loading indicator
      isLoading = true;
      document.getElementById('loadingOverlay').style.display = 'flex';
      document.getElementById('loadingText').textContent = 'Loading 360° image...';
      
      // Load texture with THREE.js
      try {
        textureLoader.load(
          // URL
          imageSrc,
          
          // onLoad callback
          function(texture) {
            log(`Texture loaded successfully: ${imageSrc}`);
            
            // Apply texture to sphere
            sphere.material.dispose();
            sphere.material = new THREE.MeshBasicMaterial({
              map: texture
            });
            
            // Hide loading overlay
            document.getElementById('progressFill').style.width = '100%';
            setTimeout(() => {
              document.getElementById('loadingOverlay').style.display = 'none';
              isLoading = false;
            }, 300);
            
            // Update thumbnails to show current active panorama
            updateActiveThumbnail(index);
            
            // Update VR navigation arrows if in VR mode
            if (isVRMode) {
              positionPathAwareArrows();
            }
          },
          
          // onProgress callback
          function(xhr) {
            const percentComplete = Math.floor((xhr.loaded / xhr.total) * 100);
            document.getElementById('progressFill').style.width = `${percentComplete}%`;
            log(`Loading texture: ${percentComplete}%`);
          },
          
          // onError callback
          function(err) {
            error(`Error loading texture from ${imageSrc}`, err);
            
            // Try loading a fallback placeholder if local file fails
            if (!USE_PLACEHOLDERS && PLACEHOLDER_IMAGES[index]) {
              log(`Trying fallback placeholder image for ${imageSrc}`);
              textureLoader.load(
                PLACEHOLDER_IMAGES[index],
                function(texture) {
                  log('Fallback texture loaded successfully');
                  sphere.material.dispose();
                  sphere.material = new THREE.MeshBasicMaterial({
                    map: texture
                  });
                  
                  document.getElementById('progressFill').style.width = '100%';
                  setTimeout(() => {
                    document.getElementById('loadingOverlay').style.display = 'none';
                    isLoading = false;
                  }, 300);
                  
                  showErrorNotification('Using placeholder image (local file not found)', 3000);
                },
                null,
                function() {
                  // If even fallback fails, just hide loading
                  document.getElementById('loadingOverlay').style.display = 'none';
                  isLoading = false;
                }
              );
            } else {
              document.getElementById('loadingOverlay').style.display = 'none';
              isLoading = false;
            }
          }
        );
      } catch (err) {
        error('Exception while loading texture', err);
        document.getElementById('loadingOverlay').style.display = 'none';
        isLoading = false;
      }
    }

    // Update UI elements for current photo
    function updateUIForCurrentPhoto(index) {
      const images = USE_PLACEHOLDERS ? PLACEHOLDER_IMAGES : PANORAMA_IMAGES;
      
      // Update location info
      const currentLocation = PANORAMA_LOCATIONS[index] || { latitude: 0, longitude: 0 };
      const locationText = `Benin, West Africa: ${currentLocation.latitude.toFixed(6)}, ${currentLocation.longitude.toFixed(6)}`;
      document.getElementById('locationName').textContent = locationText;
      
      // Update position info in the info panel
      document.getElementById('positionInfo').textContent = `${currentLocation.latitude.toFixed(6)}, ${currentLocation.longitude.toFixed(6)}`;
      document.getElementById('photoCounter').textContent = `Image ${index + 1} of ${images.length}`;
    }

    // Create thumbnail preview
    function createThumbnails() {
      const thumbnailContainer = document.getElementById('thumbnailPreview');
      thumbnailContainer.innerHTML = '';
      
      const images = USE_PLACEHOLDERS ? PLACEHOLDER_IMAGES : PANORAMA_IMAGES;
      
      // Check if we have enough placeholder images for thumbnails
      const usePlaceholders = PLACEHOLDER_IMAGES.length >= images.length;
      
      images.forEach((src, index) => {
        const thumb = document.createElement('img');
        thumb.className = 'thumbnail';
        
        // For thumbnail source, use either:
        // 1. The placeholder image if we have enough and not using original images
        // 2. The same image but with a smaller size parameter (=w100) for better performance
        if (usePlaceholders && PLACEHOLDER_IMAGES[index]) {
          // Use placeholder but with smaller size for faster loading
          const placeholderSrc = PLACEHOLDER_IMAGES[index].replace('=s0', '=w100');
          thumb.src = placeholderSrc;
        } else {
          // Use the same image but with smaller size
          const smallerSrc = src.replace('=s0', '=w100');
          thumb.src = smallerSrc;
        }
        
        thumb.alt = `Panorama ${index + 1}`;
        thumb.title = `Panorama ${index + 1}`;
        
        if (index === currentPhotoIndex) {
          thumb.classList.add('active');
        }
        
        thumb.addEventListener('click', () => {
          if (currentPhotoIndex !== index) {
            currentPhotoIndex = index;
            loadPanorama(index);
          }
        });
        
        thumbnailContainer.appendChild(thumb);
      });
    }

    // Update active thumbnail
    function updateActiveThumbnail(index) {
      const thumbnails = document.querySelectorAll('.thumbnail');
      thumbnails.forEach((thumb, i) => {
        if (i === index) {
          thumb.classList.add('active');
        } else {
          thumb.classList.remove('active');
        }
      });
    }

    // Set up event listeners for UI controls
    function setupEventListeners() {
      // Navigation buttons
      document.getElementById('prevButton').addEventListener('click', navigatePrev);
      document.getElementById('nextButton').addEventListener('click', navigateNext);
      
      // Keyboard controls
      window.addEventListener('keydown', function(evt) {
        if (evt.key === 'ArrowLeft') {
          navigatePrev();
        } else if (evt.key === 'ArrowRight') {
          navigateNext();
        }
      });
      
      // Auto-hide instructions after 10 seconds
      setTimeout(() => {
        const instructions = document.getElementById('instructions');
        if (instructions) {
          instructions.style.opacity = '0';
        }
      }, 10000);
      
      log('Event listeners set up');
    }

    // Navigate to next panorama
    function navigateNext() {
      if (isLoading) return; // Prevent navigation during loading
      
      log('Navigating to next panorama');
      
      const images = USE_PLACEHOLDERS ? PLACEHOLDER_IMAGES : PANORAMA_IMAGES;
      if (currentPhotoIndex < images.length - 1) {
        currentPhotoIndex++;
        loadPanorama(currentPhotoIndex);
      } else {
        log('Already at the last panorama');
        showErrorNotification('Already at the last image', 1500);
      }
    }

    // Navigate to previous panorama
    function navigatePrev() {
      if (isLoading) return; // Prevent navigation during loading
      
      log('Navigating to previous panorama');
      
      if (currentPhotoIndex > 0) {
        currentPhotoIndex--;
        loadPanorama(currentPhotoIndex);
      } else {
        log('Already at the first panorama');
        showErrorNotification('Already at the first image', 1500);
      }
    }

    // Fallback VR components factory
    function createFallbackVRComponents() {
      log('Creating fallback VR Button implementation');
      
      THREE.VRButton = {
        createButton: function(renderer) {
          const button = document.createElement('button');
          button.id = 'vrButton';
          button.style.display = 'block';
          button.style.padding = '12px 24px';
          button.style.border = 'none';
          button.style.borderRadius = '5px';
          button.style.background = '#0066ff';
          button.style.color = '#fff';
          button.style.font = 'normal 16px sans-serif';
          button.style.cursor = 'pointer';
          
          if (navigator.xr) {
            navigator.xr.isSessionSupported('immersive-vr').then(function(supported) {
              if (supported) {
                button.textContent = 'ENTER VR';
                button.onclick = function() {
                  // Request VR session
                  navigator.xr.requestSession('immersive-vr', {
                    optionalFeatures: ['local-floor', 'bounded-floor']
                  }).then(onSessionStarted, onRequestSessionError);
                };
              } else {
                button.textContent = 'VR NOT SUPPORTED';
                button.onclick = function() {
                  showErrorNotification('VR not supported on this device/browser', 3000);
                };
                button.style.background = '#888888';
              }
            });
          } else {
            button.textContent = 'VR NOT AVAILABLE';
            button.onclick = function() {
              showErrorNotification('WebXR not available in this browser', 3000);
            };
            button.style.background = '#888888';
          }
          
          function onSessionStarted(session) {
            session.addEventListener('end', onSessionEnded);
            
            renderer.xr.setSession(session);
            button.textContent = 'EXIT VR';
            
            button.onclick = function() {
              session.end();
            };
            
            // Emit session start event
            const event = new CustomEvent('sessionstart');
            renderer.xr.dispatchEvent(event);
          }
          
          function onSessionEnded() {
            // Emit session end event
            const event = new CustomEvent('sessionend');
            renderer.xr.dispatchEvent(event);
            
            button.textContent = 'ENTER VR';
            
            button.onclick = function() {
              navigator.xr.requestSession('immersive-vr', {
                optionalFeatures: ['local-floor', 'bounded-floor']
              }).then(onSessionStarted, onRequestSessionError);
            };
          }
          
          function onRequestSessionError(error) {
            showErrorNotification('Error entering VR: ' + error, 3000);
          }
          
          return button;
        }
      };
      
      log('Fallback VR Button created');
    }

    function createFallbackXRControllers() {
      log('Creating fallback XR Controller implementation');
      
      THREE.XRControllerModelFactory = function() {
        return {
          createControllerModel: function() {
            // Create a simple controller model (blue cylinder)
            const geometry = new THREE.CylinderGeometry(0.01, 0.02, 0.08, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0x0055ff });
            return new THREE.Mesh(geometry, material);
          }
        };
      };
    }
  </script>
</body>
</html>